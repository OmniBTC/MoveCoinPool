module coin_pool::omni_pool {
    use coin_pool::singel_pool::{RootCapability, Self, get_pool_address_by_root, destroy_proof};
    use std::option::{Option, Self};
    use std::signer;
    use std::vector;
    use aptos_std::event::{EventHandle, Self};
    use aptos_std::type_info::{TypeInfo, Self};
    use aptos_framework::bucket_table::{BucketTable, Self};


    //
    // Errors.
    //

    /// Not deployed address
    const NOT_DEPLOYED_ADDRESS: u64 = 0;

    /// Exist same coin type
    const EXIST_SAME_COINTYPE: u64 = 1;

    /// Has been initialized
    const HAS_BEEN_INITIALIZED: u64 = 2;

    /// Must been initialized
    const MUST_BEEN_INITIALIZED: u64 = 3;

    /// Must been owner
    const MUST_BEEN_OWNER: u64 = 4;

    /// Not find creator
    const NOT_FIND_CREATOR: u64 = 5;

    /// Not find whitelist
    const NOT_FIND_WHITELIST: u64 = 6;

    /// Pool creator stores root permissions and whitelist.
    /// `chain_id`: Chain id
    /// `token_id`: Token id
    /// `root`: Pool root permissions
    /// `whitelist`: Whitelist members can use root privileges.
    struct PoolInfo<phantom CoinType> has key {
        chain_id: u64,
        token_id: u64,
        root: RootCapability<CoinType>,
        whitelist: vector<address>
    }

    /// Pool manager
    /// coin_types: All pool cointype that have been created.
    /// creators: All pool creators.
    /// owner: All pool owners.
    struct PoolManage has key {
        coin_types: vector<TypeInfo>,
        /// coin_type -> creator
        creators: BucketTable<TypeInfo, address>,
        owner: address
    }

    /// User initiates events generated by five behaviors of `supply|withdraw|borrow|repay|cross`.
    /// Behaviors are independent of each other and can be processed in parallel.
    struct UserEventHandle has key {
        next_supply_nonce: u64,
        supply_event: EventHandle<SupplyEvent>,
        next_withdraw_nonce: u64,
        withdraw_event: EventHandle<WithdrawEvent>,
        next_borrow_nonce: u64,
        borrow_event: EventHandle<BorrowEvent>,
        next_repay_nonce: u64,
        repay_event: EventHandle<RepayEvent>,
        next_cross_nonce: u64,
        cross_event: EventHandle<CrossEvent>,
    }

    /// Ack events for user action events
    struct RelayerEventHandle has key {
        ack_supply_event: EventHandle<AckSupplyEvent>,
        ack_withdraw_event: EventHandle<AckWithdrawEvent>,
        ack_borrow_event: EventHandle<AckBorrowEvent>,
        ack_repay_event: EventHandle<AckRepayEvent>,
        ack_cross_event: EventHandle<AckCrossEvent>,
    }

    /// User supply event.
    struct SupplyEvent has store, drop {
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        nonce: u64
    }

    /// The user supply, but the supply fails in the remote, and the tokens are returned.
    struct AckSupplyEvent has store, drop {
        ack_nonce: u64,
        user: address,
        amount: u64,
        symbol: TypeInfo
    }

    /// User withdraw event.
    struct WithdrawEvent has store, drop {
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
        nonce: u64
    }

    /// The ack event after the user initiates a withdrawal.
    struct AckWithdrawEvent has store, drop {
        ack_nonce: u64,
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
    }

    /// User borrow event.
    struct BorrowEvent has store, drop {
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
        nonce: u64
    }

    /// The ack event after the user initiates a borrow.
    struct AckBorrowEvent has store, drop {
        ack_nonce: u64,
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
    }

    /// User repay event.
    struct RepayEvent has store, drop {
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        nonce: u64
    }

    /// The ack event after the user initiates a repay.
    struct AckRepayEvent has store, drop {
        ack_nonce: u64,
        user: address,
        amount: u64,
        symbol: TypeInfo
    }

    /// User cross event.
    struct CrossEvent has store, drop {
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
        nonce: u64
    }

    /// The ack event after the user initiates a cross.
    struct AckCrossEvent has store, drop {
        ack_nonce: u64,
        user: address,
        amount: u64,
        symbol: TypeInfo,
        src_chain_id: u64,
        src_token_id: u64,
        dst_chain_id: u64,
    }

    /// Has it been initialized.
    public fun is_initialize(): bool {
        exists<PoolManage>(@coin_pool)
    }

    /// Whether the owner of all pools
    public fun is_owner(account: &signer): bool acquires PoolManage {
        assert!(is_initialize(), MUST_BEEN_INITIALIZED);
        let account_addr = signer::address_of(account);
        borrow_global<PoolManage>(@coin_pool).owner == account_addr
    }

    /// The contract deployer initializes the pool manager.
    public entry fun initialize(account: &signer) {
        assert!(signer::address_of(account) == @coin_pool, NOT_DEPLOYED_ADDRESS);
        assert!(!is_initialize(), HAS_BEEN_INITIALIZED);

        move_to(account, PoolManage {
            coin_types: vector::empty(),
            creators: bucket_table::new(1),
            owner: @coin_pool
        });
        move_to(account, UserEventHandle {
            next_supply_nonce: 0,
            supply_event: event::new_event_handle(account),
            next_withdraw_nonce: 0,
            withdraw_event: event::new_event_handle(account),
            next_borrow_nonce: 0,
            borrow_event: event::new_event_handle(account),
            next_repay_nonce: 0,
            repay_event: event::new_event_handle(account),
            next_cross_nonce: 0,
            cross_event: event::new_event_handle(account),
        });
        move_to(account, RelayerEventHandle {
            ack_supply_event: event::new_event_handle(account),
            ack_withdraw_event: event::new_event_handle(account),
            ack_borrow_event: event::new_event_handle(account),
            ack_repay_event: event::new_event_handle(account),
            ack_cross_event: event::new_event_handle(account),
        });
    }

    /// Exist `CoinType`.
    public fun exist_coin_types<CoinType>(): bool acquires PoolManage {
        let creators = &borrow_global<PoolManage>(@coin_pool).creators;
        bucket_table::contains(creators, &type_info::type_of<CoinType>())
    }

    /// Find creator by CoinType
    public fun find_creator<CoinType>(): Option<address> acquires PoolManage {
        let creators = &mut borrow_global_mut<PoolManage>(@coin_pool).creators;
        let coin_type = type_info::type_of<CoinType>();
        let flag = bucket_table::contains(creators, &coin_type);
        if (flag) {
            let creator = *bucket_table::borrow(creators, coin_type);
            option::some(creator)
        }else {
            option::none()
        }
    }

    /// Find out if the account is in the whitelist
    /// `creator`: `PoolInfo` is stored under the pool creator account
    /// `account`: Account found
    public fun find_whitelist<CoinType>(creator: address, account: address): (bool, u64) acquires PoolInfo {
        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        vector::index_of(&pool_info.whitelist, &account)
    }

    /// Create pool. Only the owner can create pools. Can't create pools with the same CoinType.
    /// `creater`: creater
    /// `chain_id`: The chain id corresponding to the chain is in the Omni Btc protocol.
    /// `token_id`: The token id corresponding to the pool is in the Omni Btc protocol.
    public entry fun create_pool<CoinType>(creater: &signer, chain_id: u64, token_id: u64) acquires PoolManage {
        assert!(is_owner(creater), MUST_BEEN_OWNER);
        assert!(!exist_coin_types<CoinType>(), EXIST_SAME_COINTYPE);

        let create_addr = signer::address_of(creater);

        let root = singel_pool::create_pool_program<CoinType>(creater);

        let pool_info = PoolInfo<CoinType> {
            chain_id,
            token_id,
            root,
            whitelist: vector::singleton(create_addr)
        };
        move_to(creater, pool_info);

        let pool_manager = borrow_global_mut<PoolManage>(@coin_pool);
        let coin_type = type_info::type_of<CoinType>();
        vector::push_back(&mut pool_manager.coin_types, coin_type);
        bucket_table::add(&mut pool_manager.creators, coin_type, create_addr);
    }

    /// Transfer owner.
    public entry fun transfer_owner(from: &signer, to: address) acquires PoolManage {
        assert!(is_owner(from), MUST_BEEN_OWNER);

        let pool_manager = borrow_global_mut<PoolManage>(@coin_pool);
        pool_manager.owner = to;
    }

    /// Update whitelist
    /// `action`: 0 means add, 1 means remove.
    public entry fun update_whitelist<CoinType>(from: &signer, account: address, action: u64) acquires PoolManage, PoolInfo {
        assert!(is_owner(from), MUST_BEEN_OWNER);
        let result = find_creator<CoinType>();
        assert!(option::is_some(&result), NOT_FIND_CREATOR);
        let creator = option::destroy_some(result);
        let (flag, index) = find_whitelist<CoinType>(creator, account);
        if (!flag && action == 0) {
            let pool_info = borrow_global_mut<PoolInfo<CoinType>>(creator);
            vector::push_back(&mut pool_info.whitelist, account);
        };
        if (flag && action == 1) {
            let pool_info = borrow_global_mut<PoolInfo<CoinType>>(creator);
            vector::swap_remove(&mut pool_info.whitelist, index);
        }
    }

    /// Check user.
    fun check_user<CoinType>(): address acquires PoolManage {
        assert!(is_initialize(), MUST_BEEN_INITIALIZED);
        let result = find_creator<CoinType>();
        assert!(option::is_some(&result), NOT_FIND_CREATOR);
        option::destroy_some(result)
    }

    /// User supply.
    public entry fun supply<CoinType>(account: &signer, amount: u64)  acquires PoolManage, PoolInfo, UserEventHandle {
        let addr = signer::address_of(account);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let pool_address = get_pool_address_by_root(&pool_info.root);
        destroy_proof(singel_pool::supply_program<CoinType>(account, pool_address, amount));

        let event_handle = borrow_global_mut<UserEventHandle>(@coin_pool);
        event::emit_event<SupplyEvent>(&mut event_handle.supply_event, SupplyEvent {
            user: addr,
            amount,
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            nonce: event_handle.next_supply_nonce,
            symbol: type_info::type_of<CoinType>()
        });
        event_handle.next_supply_nonce = event_handle.next_supply_nonce + 1;
    }

    /// Relayer to process failed supply.
    public entry fun supply_relayer<CoinType>(relayer: &signer, account: address, amount: u64, nonce: u64)  acquires PoolManage, PoolInfo, RelayerEventHandle {
        let addr = signer::address_of(relayer);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let (flag, _) = vector::index_of(&pool_info.whitelist, &addr);
        assert!(flag, NOT_FIND_WHITELIST);

        singel_pool::withdraw_root_program(&pool_info.root, account, amount);

        let event_handle = borrow_global_mut<RelayerEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.ack_supply_event, AckSupplyEvent {
            ack_nonce: nonce,
            user: addr,
            amount,
            symbol: type_info::type_of<CoinType>()
        });
    }

    /// User withdraw.
    public entry fun withdraw<CoinType>(account: &signer, amount: u64)  acquires PoolManage, PoolInfo, UserEventHandle {
        let addr = signer::address_of(account);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);

        let event_handle = borrow_global_mut<UserEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.withdraw_event, WithdrawEvent {
            user: addr,
            amount,
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            dst_chain_id: pool_info.chain_id,
            nonce: event_handle.next_supply_nonce,
            symbol: type_info::type_of<CoinType>()
        });
        event_handle.next_withdraw_nonce = event_handle.next_withdraw_nonce + 1;
    }

    /// Relayer to process withdraw.
    public entry fun withdraw_relayer<CoinType>(relayer: &signer, account: address, amount: u64, nonce: u64)  acquires PoolManage, PoolInfo, RelayerEventHandle {
        let addr = signer::address_of(relayer);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let (flag, _) = vector::index_of(&pool_info.whitelist, &addr);
        assert!(flag, NOT_FIND_WHITELIST);

        singel_pool::withdraw_root_program(&pool_info.root, account, amount);

        let event_handle = borrow_global_mut<RelayerEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.ack_withdraw_event, AckWithdrawEvent {
            ack_nonce: nonce,
            user: addr,
            amount,
            symbol: type_info::type_of<CoinType>(),
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            dst_chain_id: pool_info.chain_id,
        });
    }

    /// User borrow.
    public entry fun borrow<CoinType>(account: &signer, amount: u64)  acquires PoolManage, PoolInfo, UserEventHandle {
        let addr = signer::address_of(account);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);

        let event_handle = borrow_global_mut<UserEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.borrow_event, BorrowEvent {
            user: addr,
            amount,
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            dst_chain_id: pool_info.chain_id,
            nonce: event_handle.next_supply_nonce,
            symbol: type_info::type_of<CoinType>()
        });
        event_handle.next_borrow_nonce = event_handle.next_borrow_nonce + 1;
    }

    /// Relayer to process borrow.
    public entry fun borrow_relayer<CoinType>(relayer: &signer, account: address, amount: u64, nonce: u64)  acquires PoolManage, PoolInfo, RelayerEventHandle {
        let addr = signer::address_of(relayer);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let (flag, _) = vector::index_of(&pool_info.whitelist, &addr);
        assert!(flag, NOT_FIND_WHITELIST);

        singel_pool::withdraw_root_program(&pool_info.root, account, amount);

        let event_handle = borrow_global_mut<RelayerEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.ack_borrow_event, AckBorrowEvent {
            ack_nonce: nonce,
            user: addr,
            amount,
            symbol: type_info::type_of<CoinType>(),
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            dst_chain_id: pool_info.chain_id,
        });
    }

    /// User repay.
    public entry fun repay<CoinType>(account: &signer, amount: u64)  acquires PoolManage, PoolInfo, UserEventHandle {
        let addr = signer::address_of(account);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let pool_address = get_pool_address_by_root(&pool_info.root);
        destroy_proof(singel_pool::supply_program<CoinType>(account, pool_address, amount));

        let event_handle = borrow_global_mut<UserEventHandle>(@coin_pool);
        event::emit_event<RepayEvent>(&mut event_handle.repay_event, RepayEvent {
            user: addr,
            amount,
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            nonce: event_handle.next_repay_nonce,
            symbol: type_info::type_of<CoinType>()
        });
        event_handle.next_repay_nonce = event_handle.next_repay_nonce + 1;
    }

    /// Relayer to process failed repay.
    public entry fun repay_relayer<CoinType>(relayer: &signer, account: address, amount: u64, nonce: u64)  acquires PoolManage, PoolInfo, RelayerEventHandle {
        let addr = signer::address_of(relayer);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let (flag, _) = vector::index_of(&pool_info.whitelist, &addr);
        assert!(flag, NOT_FIND_WHITELIST);

        singel_pool::withdraw_root_program(&pool_info.root, account, amount);

        let event_handle = borrow_global_mut<RelayerEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.ack_repay_event, AckRepayEvent {
            ack_nonce: nonce,
            user: addr,
            amount,
            symbol: type_info::type_of<CoinType>()
        });
    }

    /// User cross
    public entry fun cross<CoinType>(account: &signer, amount: u64, dst_chain_id: u64)  acquires PoolManage, PoolInfo, UserEventHandle {
        let addr = signer::address_of(account);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let pool_address = get_pool_address_by_root(&pool_info.root);
        destroy_proof(singel_pool::supply_program<CoinType>(account, pool_address, amount));

        let event_handle = borrow_global_mut<UserEventHandle>(@coin_pool);
        event::emit_event<CrossEvent>(&mut event_handle.cross_event, CrossEvent {
            user: addr,
            amount,
            src_chain_id: pool_info.chain_id,
            src_token_id: pool_info.token_id,
            dst_chain_id,
            nonce: event_handle.next_cross_nonce,
            symbol: type_info::type_of<CoinType>()
        });
        event_handle.next_cross_nonce = event_handle.next_cross_nonce + 1;
    }

    /// Relayer to process cross.
    public entry fun cross_relayer<CoinType>(
        relayer: &signer,
        account: address,
        amount: u64,
        nonce: u64,
        src_chain_id: u64,
        src_token_id: u64
    )  acquires PoolManage, PoolInfo, RelayerEventHandle {
        let addr = signer::address_of(relayer);
        let creator = check_user<CoinType>();

        let pool_info = borrow_global<PoolInfo<CoinType>>(creator);
        let (flag, _) = vector::index_of(&pool_info.whitelist, &addr);
        assert!(flag, NOT_FIND_WHITELIST);

        singel_pool::withdraw_root_program(&pool_info.root, account, amount);

        let event_handle = borrow_global_mut<RelayerEventHandle>(@coin_pool);
        event::emit_event(&mut event_handle.ack_cross_event, AckCrossEvent {
            ack_nonce: nonce,
            user: addr,
            amount,
            symbol: type_info::type_of<CoinType>(),
            src_chain_id,
            src_token_id,
            dst_chain_id: pool_info.chain_id
        });
    }


    /// Facilitate future contract upgrades.
    /// `CoinType`: results in multiple calls.
    /// Returns: root permissions and whitelisting
    public fun upgrade<CoinType>(from: &signer): (u64, u64, RootCapability<CoinType>, vector<address>) acquires PoolManage, PoolInfo {
        assert!(is_owner(from), MUST_BEEN_OWNER);
        let result = find_creator<CoinType>();
        assert!(option::is_some(&result), NOT_FIND_CREATOR);
        let creator = option::destroy_some(result);

        let PoolInfo<CoinType> {
            chain_id,
            token_id,
            root,
            whitelist
        } = move_from<PoolInfo<CoinType>>(creator);
        (chain_id, token_id, root, whitelist)
    }
}
